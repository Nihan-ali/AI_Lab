# -*- coding: utf-8 -*-
"""AI.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wyRsA706-8Mxb0ZSPRa5x54QVnuWaaAy

AI codes

N queen poblem using hill climbing
"""

import random

def generate_random_board(n):
    return [random.randint(0, n-1) for _ in range(n)]

def calculate_attacking_pairs(board):
    n = len(board)
    count = 0
    for i in range(n):
        for j in range(i + 1, n):
            if board[i] == board[j] or abs(board[i] - board[j]) == abs(i - j):
                count += 1
    return count

def hill_climbing_queens(n, max_attempts=1000):
    attempts = 0
    while attempts < max_attempts:
        current_board = generate_random_board(n)
        current_attacking_pairs = calculate_attacking_pairs(current_board)

        while current_attacking_pairs > 0:
            neighbors = []
            for col in range(n):
                for row in range(n):
                    if current_board[col] != row:
                        neighbor_board = current_board.copy()
                        neighbor_board[col] = row
                        neighbors.append(neighbor_board)

            best_neighbor = current_board
            best_attacking_pairs = current_attacking_pairs
            for neighbor in neighbors:
                attacking_pairs = calculate_attacking_pairs(neighbor)
                if attacking_pairs < best_attacking_pairs:
                    best_neighbor = neighbor
                    best_attacking_pairs = attacking_pairs

            if best_attacking_pairs >= current_attacking_pairs:
                break

            current_board = best_neighbor
            current_attacking_pairs = best_attacking_pairs

        if current_attacking_pairs == 0:
            return current_board
        attempts += 1

    return None

def print_board(board):

    n = len(board)
    for row in range(n):
        line = ""
        for col in range(n):
            if board[col] == row:
                line += "Q "
            else:
                line += ". "
        print(line)

if __name__ == "__main__":
    N = 8
    solution = hill_climbing_queens(N)

    if solution:
        print("Solution found:")
        print_board(solution)
    else:
        print("No solution found within the specified attempts.")

"""### 8 Puzzle problem solution"""

import heapq

# Define the goal state
goal_state = ((0,1, 2), (3,4, 5), (6,7, 8))

# Define possible moves
moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # Right, Down, Left, Up

# Function to calculate the Manhattan distance heuristic
def manhattan_distance(state):
    distance = 0
    for i in range(3):
        for j in range(3):
            if state[i][j] != 0:
                goal_row, goal_col = divmod(state[i][j] - 1, 3)
                distance += abs(i - goal_row) + abs(j - goal_col)
    return distance

# Function to check if a state is valid
def is_valid(x, y):
    return 0 <= x < 3 and 0 <= y < 3

# Function to find the possible next states
def get_neighbors(state):
    zero_x, zero_y = None, None
    for i in range(3):
        for j in range(3):
            if state[i][j] == 0:
                zero_x, zero_y = i, j
                break
    neighbors = []
    for dx, dy in moves:
        new_x, new_y = zero_x + dx, zero_y + dy
        if is_valid(new_x, new_y):
            new_state = [list(row) for row in state]
            new_state[zero_x][zero_y], new_state[new_x][new_y] = new_state[new_x][new_y], new_state[zero_x][zero_y]
            neighbors.append((tuple(map(tuple, new_state)), (new_x, new_y)))
    return neighbors

# Function to solve the puzzle using A* search
def solve_puzzle(initial_state):
    priority_queue = [(manhattan_distance(initial_state), 0, initial_state)]
    visited = set()
    came_from = {}

    while priority_queue:
        _, cost, current_state = heapq.heappop(priority_queue)

        if current_state == goal_state:
            path = []
            while current_state in came_from:
                path.append(current_state)
                current_state = came_from[current_state]
            path.append(initial_state)
            path.reverse()
            return path, cost

        if current_state in visited:
            continue

        visited.add(current_state)

        for neighbor, move in get_neighbors(current_state):
            if neighbor not in visited:
                priority = manhattan_distance(neighbor) + cost + 1
                heapq.heappush(priority_queue, (priority, cost + 1, neighbor))
                came_from[neighbor] = current_state

    return None, None  # Return None when no solution is found

# Function to pretty print the puzzle state
def print_puzzle(state):
    for row in state:
        print(" ".join(str(cell) for cell in row))
    print("\n")

# Example usage:
initial_state = ((4, 3, 7),
        (6, 8, 5),
        (2, 1, 0))
result, cost = solve_puzzle(initial_state)

if result:
    for i, state in enumerate(result):
        print(f"Step {i}:")
        print_puzzle(state)
    print(f"Total cost: {cost}")
else:
    print("No solution found.")

import itertools

def get_value(word, substitution):
    s = 0
    factor = 1
    for letter in reversed(word):
        s += factor * substitution[letter]
        factor *= 10
    return s

def solve_cryptarithmetic(equation):
    # Split equation into left and right
    left, right = equation.lower().replace(' ', '').split('=')
    # Split words in the left part
    left = left.split('+')
    # Create a list of used letters
    letters = set(right)
    for word in left:
        for letter in word:
            letters.add(letter)
    letters = list(letters)

    digits = range(10)
    for perm in itertools.permutations(digits, len(letters)):
        sol = dict(zip(letters, perm))

        # Check if the current mapping satisfies the equation
        if sum(get_value(word, sol) for word in left) == get_value(right, sol):
            print(' + '.join(str(get_value(word, sol)) for word in left) + " = {} (mapping: {})".format(get_value(right, sol), sol))
            break

if __name__ == '__main__':
    solve_cryptarithmetic('send + more = money')

def findans(question: str):
	question_words = [word.lower() for word in question.split()]
	question_words = set(question_words)

	ret = []
	with open("q.txt", "r") as file:
		lines = file.read().split('\n')

		for line in lines:
			line_words = [word.lower() for word in line.split() ]
			line_words = set(line_words)

			cnt = 0
			for word in line_words:
				if word in question_words:
					cnt += 1

			ret.append([cnt, line])

	ret.sort(reverse=True)
	if len(ret):
		return ret[0][1]

	return "Sorry, I don't have an answer for that."

while True:
    question = input("Ask me a question. Type 'exit' to stop: ")
    if question.lower() == 'exit':
        break

    print(findans(question))
    

def findans(question: str):
	question_words = [word.lower() for word in question.split()]
	question_words = set(question_words)

	ret = []
	with open("q.txt", "r") as file:
		lines = file.read().split('\n')

		for line in lines:
			line_words = [word.lower() for word in line.split() ]
			line_words = set(line_words)

			cnt = 0
			for word in line_words:
				if word in question_words:
					cnt += 1

			ret.append([cnt, line])

	ret.sort(reverse=True)
	if len(ret):
		return ret[0][1]

	return "Sorry, I don't have an answer for that."

while True:
    question = input("Ask me a question. Type 'exit' to stop: ")
    if question.lower() == 'exit':
        break

    print(findans(question))

"""#### Suduku Solution Using Python"""

def printSuduku(board):
    for i in range (9):
        for j in range(9):
            print(board[i][j],end=' ')
        print()


def findEmpty(board,pos):

    for i in range(9):
        for j in range(9):
            if board[i][j]==0:
                pos[0]=i
                pos[1]=j
                return True
    return False


def isSafe(board,row,column,val):
    for i in range (9):
        if board[row][i]==val or board[i][column]==val:
            return False
    startRow,startCol = row-row%3,column-column%3
    for i in range(3):
        for j in range(3):
            if board[startRow+i][startCol+j]==val:
                return False
    return True

def solve(board):
    pos = [0,0]
    if(not findEmpty(board,pos)):
        return True
    row,column = pos[0],pos[1]
    for i in range (1,10):
        if(isSafe(board,row,column,i)):
            board[row][column]=i
            if(solve(board)):
                return True
            board[row][column]=0
    return False


suduku_board = [
    [0, 0, 0, 2, 4, 0, 0, 1, 0],
    [6, 0, 0, 1, 0, 0, 2, 0, 8],
    [0, 0, 0, 0, 0, 6, 0, 7, 0],
    [0, 0, 5, 0, 0, 3, 0, 4, 0],
    [0, 0, 8, 9, 0, 1, 7, 0, 0],
    [0, 3, 0, 7, 0, 0, 5, 0, 0],
    [0, 7, 0, 8, 0, 0, 0, 0, 0],
    [5, 0, 1, 0, 0, 2, 0, 0, 3],
    [0, 4, 0, 0, 6, 5, 0, 0, 0]
    ]
if(solve(suduku_board)):
    print('Here is My solution')
    printSuduku(suduku_board)
else:
    print('sorry bro!!!!!')
